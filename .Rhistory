# Korpus und Pakete laden
require(dplyr)
require(polmineR)
use("GermaParl")
# Vorbereitung
# sAttribute für den Korpus in data.table schreiben
sattrib_gp <- sAttributes("GERMAPARL", c("agenda_item", "speaker", "role", "date"))
# Resultat ist eine sehr große Tabelle. sAttributes werden für jeden Absatz gesetzt, für die erste Analyse interessiert aber nur ein Absatz pro Rede. Also kann das identische Folgeelement entfernt werden.
sattrib_gp_tf <- (sattrib_gp[-nrow(sattrib_gp)]!=sattrib_gp[-1])
speaker_gp_row_unique <- sattrib_gp[with(sattrib_gp, c(sattrib_gp_tf[,1]|sattrib_gp_tf[,2], TRUE)),]
# ----------------------- item + date, max_values -------------------
# Wie viele Rednerinnen sprechen hintereinander, ohne Einschub durch Präsidenten? Die Funktion ave zählt für jeden aufeinanderfolgenden role == "mp" hoch, bis ein role != "mp" erscheint.
# https://stackoverflow.com/questions/48551492/count-consecutive-true-values-within-each-block-separately?noredirect=1&lq=1
speaker_gp_row_unique$is_mp <- speaker_gp_row_unique$role == "mp"
speaker_gp_row_unique$rep_role <- ave(speaker_gp_row_unique$is_mp, cumsum(!speaker_gp_row_unique$is_mp), FUN = cumsum)
# anzahl aller rednerinnen pro agenda_item hinzugefügt
speaker_gp_row_unique <- speaker_gp_row_unique %>% add_count(agenda_item, date)
# maximalwerte für jedes agenda_item mit rep_role > 3 filtern. Für die Analyse interessieren jeweils nur die lokalen maxima von rep_role, also der jeweils letzte Wert, bevor eine Reihe repeating roles wieder unterbrochen wird.
max_rep_role <- speaker_gp_row_unique %>% filter(rep_role > 3) %>% group_by(agenda_item, date) %>% filter(rep_role == max(rep_role))
# für später: agenda_item als numeric
max_rep_role$agenda_item <- as.numeric(max_rep_role$agenda_item)
# Verteilung von max_rep_role über agenda_item, Häufigkeit und date
# wie ist die zahl der maximalen konsekutiven reden über agenda_items verteilt? Wenn Reden eher im späteren verlauf der Sitzung zu protokoll gegeben werden, ist agenda_item < 9 womöglich ein anderes Phänomen.
barplot(table(sort(as.numeric(max_rep_role$agenda_item))), main = "conseq_speech per agenda_item")
# Verteilung der maximalen konsekutiven reden (> 3).
barplot(table(sort(as.numeric(max_rep_role$rep_role))), main = "frequency of conseq_speech")
# verteilung über Date. Das ist überraschend. hier werden alle agenda_items mit hoher zahl konsekutiver mps pro tag aufsummiert. Ich hätte erwartet, dass vielleicht drei oder vier agenda_items pro tag zu protokoll gegeben werden. Die auffälligen Zahlen betreffen nur einen begrenzten Zeitraum zwischen Mai 2008 und Juni 2013, also vor allem lp 16. Das könnte am stenographischen Dienst liegen
barplot(table(sort(as.Date(max_rep_role$date))), main = "conseq_speech per date")
# quotient aus aufeinanderfolgenden mps und allen reden pro agenda_item
max_rep_role$anteil_rep <- max_rep_role$rep_role/max_rep_role$n
# histogramm des quotienten
hist(max_rep_role$anteil_rep, breaks = 100)
# Tabelle bereinigen auf alle mit anteil_rep größer 0.8
max_rep_role_quot <- max_rep_role %>% filter(anteil_rep > 0.8)
# und die grafiken von oben nochmal zum vergleich
barplot(table(sort(as.numeric(max_rep_role_quot$agenda_item))), main = "conseq_speech per agenda_item")
barplot(table(sort(as.numeric(max_rep_role_quot$rep_role))), main = "frequency of conseq_speech")
barplot(table(sort(as.Date(max_rep_role_quot$date))), main = "conseq_speech per date")
max_rep_role_quot$diff <- max_rep_role_quot$n - max_rep_role_quot$rep_role
